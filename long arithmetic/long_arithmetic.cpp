#include <algorithm>
#include <string>
#include <iostream>
#include <vector>

using namespace std;
int base = 10; // система счисления

/*
-----------------------------------------------------------------------------
  функция делит число a на короткое число b и возвращает остаток от деления
-----------------------------------------------------------------------------
*/

int Remainder_of_the_division(vector<int> a, int b){
    // r - обозначает текущий остаток, к которому будет приписана очередная цифра
    int r = 0;
    // изначально остаток 0

    int n1 = a.size(); // длина большого числа
    for(int i=0; i<n1; i++){
        // цикл от старших цифр к младшим
        r = r * base + a[i];
        // приписывание очередной цифры
        a[i] = r / b;
        // запись частного в результат
        r %= b;
    }
    return r;
}


/*
----------------------------------------
  функция прибавляет к числу a число b
----------------------------------------
*/

vector<int> addition(vector<int> a, vector<int> b){
    if(a[0] < b[0]){
        a[0] = b[0];
    }
    // складывать нужно до размера большего числа  
    int r = 0;
    /*
        r - обозначает сколько у нас "в уме"
        при сложение младших цифр в уме у нас 0
    */
    for(int i = 1; i <= a[0]; i++){
        a[i] += b[i] +r; // сумма очередных цифр и переноса
        if(a[i] >= 10){ // случай, когда происходит перенос в следующий разряд
            r = 1;
             a[i] -= 10;
        }
        else{
            // случай, когда переноса не происходит
             r = 0;
        }
    }

    // если после сложения остался еще перенос, то нужно добавить еще одну цифру
    if(r > 0){
        a[0]++;
        a[a[0]] = r;
    }

    return a;
}


/*
----------------------------------------
  функция вычитает из числа a число b
----------------------------------------
*/

vector<int> subtraction(vector<int> a, vector<int> b){
    // r - обозначает был ли заем единицы из текущего разряда
    int r = 0;
    // заем из младшего разряда отсутствует
    for(int i = 1; i <= a[0]; i++){
        a[i] -= b[i] + r;
        // разность очередных цифр с учетом заема
        if(a[i] < 0){
            // случай, когда происходит заем из следующего разряда
            r = 1;
            a[i] += base;
        }
        else{
            // случай, когда заем не происходит
            r = 0;
        }
    }
    /*
       Разность может содержать меньше цифр,
       поэтому нужно при необходимости уменьшить количество цифр
    */
    while(a[0] > 1 && a[a[0]] == 0){
        --a[0];
    }

    return a;
}


/*
-----------------------------------------------
  функция умножает число a на короткое число b
-----------------------------------------------
*/

vector<int> multiplication (vector<int> a, int b){
    // r - обозначает перенос в текущий разряд
    int r = 0;
    // перенос в младший разряд отсутствует
    for(int i = 1; i <= a[0]; i++){
        a[i] = a[i] * b + r;
        // произведение очередной цифры и короткого числа с учетом переноса в текущий разряд
        r = a[i] / base;
        // вычисление переноса в следующий разряд
        a[i] -= r *base;
        // оставляем только часть произведения меньшую base
    }

    /*
       Если после умножения остался еще перенос, то нужно добавить еще цифру.
       Может потребоваться добавить несколько цифр, если число b больше base
    */
    while(r > 0){
        a[0]++;
        a[a[0]] = r % base;
        r = r / base;
    }

    return a;
}

/*
----------------------------------------
  функция умножает число a на число b
----------------------------------------
*/

vector<int> multiplication_huge (vector<int> a, vector<int> b){
    vector<int> c(max(a.size(), b.size()), 0);

    // c - результат умножения. В данном случае нельзя записывать результат в тот же массив.

    for(int i = 1; i <= a[0]; i++){
        int r = 0, j;
        for(j = 1; j <= b[0] || r > 0; j++){
            // пока есть перенос или в b есть еще цифры
            c[i + j - 1] += a[i] * b[j] + r;
            /*
                при умножении на предыдущие цифры в c уже записано
                некоторое значение, поэтому нужно прибавлять, а не
                присваивать
            */
            r = c[i + j - 1] / base;
            c[i + j - 1] -= r * base;
        }
    }
    c[0] = a[0] + b[0];

    // максимально возможное количество цифр в ответе
    a = c; // переместим ответ в массив a

    // но цифр может оказаться меньше
    while(a[0] > 1 && a[a[0]] == 0){
        --a[0];
    }

    return a;
}


int main(){
    string str1; cin >> str1;
    string str2; cin >> str2;
    
    return 0;
}
